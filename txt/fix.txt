Kevin Kelleher suggested an interesting way to compare programming languages: to describe each in terms of the problem it fixes. The surprising thing is how many, and how well, languages can be described this way. 

 Algol: Assembly language is too low-level. 

Pascal: Algol doesn't have enough data types. 

Modula: Pascal is too wimpy for systems programming. 

<!-- Python: Modula-3 is scary. --> Simula: Algol isn't good enough at simulations. 

Smalltalk: Not everything in Simula is an object. 

Fortran: Assembly language is too low-level. 

Cobol: Fortran is scary. 

PL/1: Fortran doesn't have enough data types. 

Ada: Every existing language is missing something. 

Basic: Fortran is scary. 

APL: Fortran isn't good enough at manipulating arrays. 

J: APL requires its own character set. 

C: Assembly language is too low-level. 

C++: C is too low-level. 

Java: C++ is a kludge. And Microsoft is going to crush us. 

C#: Java is controlled by Sun. <!-- Javascript: Java is scary. --> 

Lisp: Turing Machines are an awkward way to describe computation. 

Scheme: MacLisp is a kludge. 

T: Scheme has no libraries. 

Common Lisp: There are too many dialects of Lisp. 

Dylan: Scheme has no libraries, and Lisp syntax is scary. 

<!-- Curl: Lisp syntax is scary, and XML is redundant.Arc: Scheme has no libraries, and both could be denser. --> Perl: Shell scripts/awk/sed are not enough like programming languages. 

Python: Perl is a kludge. 

Ruby: Perl is a kludge, and Lisp syntax is scary. 

Prolog: Programming is not enough like logic. 

 

 <!-- There are a lot of languages I haven't been able to figure out how to describe this way.  Suggestions would be appreciated about any languages missing from the list.What I'm looking for is not exactly what motivated the language designer (Smalltalk was originally intended for children) but what niche the language first lodged in. What was the appeal of the language to its first users? -->